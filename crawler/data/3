
http://old-www.cs.dartmouth.edu/~cs50/data/tse/wikipedia/wiki/Binary_heap.html
2
Binary heap Wikipedia the free encyclopedia a lang ar a lang kk arab a lang mzn a lang ps a lang ur text decoration none cache key enwiki resourceloader filter minify css d a aa f a dc f be e if window mw mw config set wgCanonicalNamespace wgCanonicalSpecialPageName false wgNamespaceNumber wgPageName Binary heap wgTitle Binary heap wgCurRevisionId wgRevisionId wgArticleId wgIsArticle true wgIsRedirect false wgAction view wgUserName null wgUserGroups wgCategories Heaps data structures wgBreakFrames false wgPageContentLanguage en wgPageContentModel wikitext wgSeparatorTransformTable wgDigitTransformTable wgDefaultDateFormat dmy wgMonthNames January February March April May June July August September October November December wgMonthNamesShort Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec wgRelevantPageName Binary heap wgIsProbablyEditable true wgRestrictionEdit wgRestrictionMove wgWikiEditorEnabledModules toolbar true dialogs true hidesig true templateEditor false templates false preview false previewDialog false publish false toc false wgBetaFeaturesFeatures wgVisualEditor isPageWatched false magnifyClipIconURL bits wikimedia org static wmf skins common images magnify clip png pageLanguageCode en pageLanguageDir ltr svgMaxSize wikilove recipient wikilove anon wgGuidedTourHelpGuiderUrl Help Guided tours guider wgFlowTermsOfUseEdit By saving changes you agree to our u Ca class external text href wikimediafoundation org wiki Terms of use u ETerms of Use u C a u E and agree to irrevocably release your text under the u Ca rel nofollow class external text href creativecommons org licenses by sa u ECC BY SA License u C a u E and u Ca class external text href en wikipedia org wiki Wikipedia Text of the GNU Free Documentation License u EGFDL u C a u E wgULSAcceptLanguageList es es es wgULSCurrentAutonym English wgFlaggedRevsParams tags status levels quality pristine wgStableRevisionId null wgCategoryTreePageCategoryOptions mode hideprefix showcount true namespaces false wgNoticeProject wikipedia wgWikibaseItemId Q if window mw mw loader implement user options function mw user options set ccmeonemails cols date default diffonly disablemail editfont default editondblclick editsectiononrightclick enotifminoredits enotifrevealaddr enotifusertalkpages enotifwatchlistpages extendwatchlist fancysig forceeditsummary gender unknown hideminor hidepatrolled imagesize math minordefault newpageshidepatrolled nickname norollbackdiff numberheadings previewonfirst previewontop rcdays rclimit rememberpassword rows showhiddencats false shownumberswatching showtoolbar skin vector stubthreshold thumbsize underline uselivepreview usenewrc watchcreations watchdefault watchdeletion watchlistdays watchlisthideanons watchlisthidebots watchlisthideliu watchlisthideminor watchlisthideown watchlisthidepatrolled watchmoves wllimit useeditwarning prefershttps flaggedrevssimpleui flaggedrevsstable flaggedrevseditdiffs true flaggedrevsviewdiffs false usebetatoolbar usebetatoolbar cgd visualeditor enable visualeditor enable experimental visualeditor betatempdisable wikilove enabled echo subscriptions web page review true echo subscriptions email page review false ep showtoplink false ep bulkdelorgs false ep bulkdelcourses true ep showdyk true echo subscriptions web education program true echo subscriptions email education program false echo notify show link true echo show alert true echo email frequency echo email format html echo subscriptions email system true echo subscriptions web system true echo subscriptions email other false echo subscriptions web other true echo subscriptions email edit user talk false echo subscriptions web edit user talk true echo subscriptions email reverted false echo subscriptions web reverted true echo subscriptions email article linked false echo subscriptions web article linked false echo subscriptions email mention false echo subscriptions web mention true echo subscriptions web edit thank true echo subscriptions email edit thank false echo subscriptions web flow discussion true echo subscriptions email flow discussion false gettingstarted task toolbar show intro true uls preferences language en variant gan gan variant iu iu variant kk kk variant ku ku variant shi shi variant sr sr variant tg tg variant uz uz variant zh zh searchNs true searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false gadget teahouse gadget ReferenceTooltips gadget DRN wizard gadget charinsert gadget mySandbox variant en mw loader implement user tokens function mw user tokens set editToken patrolToken false watchToken false cache key enwiki resourceloader filter minify js e d ede d d dc cd if window mw mw loader load mediawiki page startup mediawiki legacy wikibits mediawiki legacy ajax ext centralauth centralautologin skins vector compactPersonalBar defaultTracking ext visualEditor viewPageTarget init ext uls init ext uls interface wikibase client init ext centralNotice bannerController skins vector js body behavior url w static wmf skins vector csshover min htc Binary heap From Wikipedia the free encyclopedia Jump to navigation search Binary Heap Type Tree Time complexity in big O notation Average Worst case Space O n O n Search Not supported Not supported Insert O O log n Delete O log n O log n Example of a complete binary max heap Example of a complete binary min heap A binary heap is a heap data structure created using a binary tree It can be seen as a binary tree with two additional constraints Shape property The tree is a complete binary tree that is all levels of the tree except possibly the last one deepest are fully filled and if the last level of the tree is not complete the nodes of that level are filled from left to right Heap property All nodes are either greater than or equal to or less than or equal to each of its children according to a comparison predicate defined for the heap Heaps with a mathematical greater than or equal to comparison predicate are called max heaps those with a mathematical less than or equal to comparison predicate are called min heaps Min heaps are often used to implement priority queues Since the ordering of siblings in a heap is not specified by the heap property a single node s two children can be freely interchanged unless doing so violates the shape property compare with treap The binary heap is a special case of the d ary heap in which d Contents Heap operations Insert Delete Building a heap Heap implementation Derivation of index equations Child nodes Parent node See also Notes References External links Heap operations edit Both the insert and remove operations modify the heap to conform to the shape property first by adding or removing from the end of the heap Then the heap property is restored by traversing up or down the heap Both operations take O log n time Insert edit To add an element to a heap we must perform an up heap operation also known as bubble up percolate up sift up trickle up heapify up or cascade up by following this algorithm Add the element to the bottom level of the heap Compare the added element with its parent if they are in the correct order stop If not swap the element with its parent and return to the previous step The number of operations required is dependent on the number of levels the new element must rise to satisfy the heap property thus the insertion operation has a time complexity of O log n However in Thomas Porter and Istvan Simon proved that the function for the average number of levels an inserted node moves up is upper bounded by the constant The average number of operations required for an insertion into a binary heap is since one additional comparison is made that does not result in the inserted node moving up a level Thus on average binary heap insertion has a constant O time complexity Intuitively this makes sense since approximately of the elements are leaves and approximately of the elements are in the bottom two levels it is likely that the new element to be inserted will only move a few levels upwards to maintain the heap As an example of binary heap insertion say we have a max heap and we want to add the number to the heap We first place the in the position marked by the X However the heap property is violated since is greater than so we need to swap the and the So we have the heap looking as follows after the first swap However the heap property is still violated since is greater than so we need to swap again which is a valid max heap There is no need to check the children after this Before we placed on X the heap was valid meaning is greater than If is greater than and is greater than then must be greater than because of the transitive relation Delete edit The procedure for deleting the root from the heap effectively extracting the maximum element in a max heap or the minimum element in a min heap and restoring the properties is called down heap also known as bubble down percolate down sift down trickle down heapify down cascade down and extract min max Replace the root of the heap with the last element on the last level Compare the new root with its children if they are in the correct order stop If not swap the element with one of its children and return to the previous step Swap with its smaller child in a min heap and its larger child in a max heap So if we have the same max heap as before We remove the and replace it with the Now the heap property is violated since is greater than In this case swapping the two elements and is enough to restore the heap property and we need not swap elements further The downward moving node is swapped with the larger of its children in a max heap in a min heap it would be swapped with its smaller child until it satisfies the heap property in its new position This functionality is achieved by the Max Heapify function as defined below in pseudocode for an array backed heap A of length heap length A Note that A is indexed starting at not as is common in many real programming languages Max Heapify A i left i right i largest i if left heap length A and A left gt A largest then largest left if right heap length A and A right gt A largest then largest right if largest i then swap A i A largest Max Heapify A largest For the above algorithm to correctly re heapify the array the node at index i and its two direct children must violate the heap property If they do not the algorithm will fall through with no change to the array The down heap operation without the preceding swap can also be used to modify the value of the root even when an element is not being deleted In the worst case the new root has to be swapped with its child on each level until it reaches the bottom level of the heap meaning that the delete operation has a time complexity relative to the height of the tree or O log n Building a heap edit A heap could be built by successive insertions This approach requires time because each insertion takes time and there are elements However this is not the optimal method The optimal method starts by arbitrarily putting the elements on a binary tree respecting the shape property the tree could be represented by an array see below Then starting from the lowest level and moving upwards shift the root of each subtree downward as in the deletion algorithm until the heap property is restored More specifically if all the subtrees starting at some height measured from the bottom have already been heapified the trees at height can be heapified by sending their root down along the path of maximum valued children when building a max heap or minimum valued children when building a min heap This process takes operations swaps per node In this method most of the heapification takes place in the lower levels Since the height of the heap is the number of nodes at height is Therefore the cost of heapifying all subtrees is This uses the fact that the given infinite series h h converges to The exact value of the above the worst case number of comparisons during the heap construction is known to be equal to where s n is the sum of all digits of the binary representation of n and e n is the exponent of in the prime factorization of n The Build Max Heap function that follows converts an array A which stores a complete binary tree with n nodes to a max heap by repeatedly using Max Heapify in a bottom up manner It is based on the observation that the array elements indexed by floor n floor n n are all leaves for the tree thus each is a one element heap Build Max Heap runs Max Heapify on each of the remaining tree nodes Build Max Heap A heap length A length A for i floor length A downto do Max Heapify A i Heap implementation edit A small complete binary tree stored in an array Comparison between a binary heap and an array implementation Heaps are commonly implemented with an array Any binary tree can be stored in an array but because a heap is always an almost complete binary tree it can be stored compactly No space is required for pointers instead the parent and children of each node can be found by arithmetic on array indices These properties make this heap implementation a simple example of an implicit data structure or Ahnentafel list Details depend on the root position which in turn may depend on constraints of a programming language used for implementation or programmer preference Specifically sometimes the root is placed at index sacrificing space in order to simplify arithmetic The peek operation find min or find max simply returns the value of the root and is thus O Let n be the number of elements in the heap and i be an arbitrary valid index of the array storing the heap If the tree root is at index with valid indices through n then each element a at index i has children at indices i and i its parent i where is the floor function Alternatively if the tree root is at index with valid indices through n then each element a at index i has children at indices i and i its parent at index i This implementation is used in the heapsort algorithm where it allows the space in the input array to be reused to store the heap i e the algorithm is done in place The implementation is also useful for use as a Priority queue where use of a dynamic array allows insertion of an unbounded number of items The upheap downheap operations can then be stated in terms of an array as follows suppose that the heap property holds for the indices b b e The sift down function extends the heap property to b b b e Only index i b can violate the heap property Let j be the index of the largest child of a i for a max heap or the smallest child for a min heap within the range b e If no such index exists because i gt e then the heap property holds for the newly extended range and nothing needs to be done By swapping the values a i and a j the heap property for position i is established At this point the only problem is that the heap property might not hold for index j The sift down function is applied tail recursively to index j until the heap property is established for all elements The sift down function is fast In each step it only needs two comparisons and one swap The index value where it is working doubles in each iteration so that at most log e steps are required For big heaps and using virtual memory storing elements in an array according to the above scheme is inefficient almost every level is in a different page B heaps are binary heaps that keep subtrees in a single page reducing the number of pages accessed by up to a factor of ten The operation of merging two binary heaps takes n for equal sized heaps The best you can do is in case of array implementation simply concatenating the two heap arrays and build a heap of the result A heap on n elements can be merged with a heap on k elements using O log n log k key comparisons or in case of a pointer based implementation in O log n log k time An algorithm for splitting a heap on n elements into two heaps on k and n k elements respectively based on a new view of heaps as an ordered collections of subheaps was presented in The algorithm requires O log n log n comparisons The view also presents a new and conceptually simple algorithm for merging heaps When merging is a common task a different heap implementation is recommended such as binomial heaps which can be merged in O log n Additionally a binary heap can be implemented with a traditional binary tree data structure but there is an issue with finding the adjacent element on the last level on the binary heap when adding an element This element can be determined algorithmically or by adding extra data to the nodes called threading the tree instead of merely storing references to the children we store the inorder successor of the node as well It is possible to modify the heap structure to allow extraction of both the smallest and largest element in time To do this the rows alternate between min heap and max heap The algorithms are roughly the same but in each step one must consider the alternating rows with alternating comparisons The performance is roughly the same as a normal single direction heap This idea can be generalised to a min max median heap Derivation of index equations edit In an array based heap the children and parent of a node can be located via simple arithmetic on the node s index This section derives the relevant equations for heaps with their root at index with additional notes on heaps with their root at index To avoid confusion we ll define the level of a node as its distance from the root such that the root itself occupies level Child nodes edit For a general node located at index beginning from we will first derive the index of its right child Let node be located in level and note that any level contains exactly nodes Furthermore there are exactly nodes contained in the layers up to and including layer think of binary arithmetic Because the root is stored at the th node will be stored at index Putting these observations together yields the following expression for the index of the last node in layer l Let there be nodes after node in layer L such that Each of these nodes must have exactly children so there must be nodes separating s right child from the end of its layer As required Noting that the left child of any node is always place before its right child we get If the root is located at index instead of the last node in each level is instead at index Using this throughout yields and for heaps with their root at Parent node edit Every node is either the left or right child of its parent so we know that either of the following is true Hence Now consider the expression If node is a left child this gives the result immediately however it also gives the correct result if node is a right child In this case must be even and hence must be odd Therefore irrespective of whether a node is a left or right child its parent can be found by the expression See also edit Heap Heapsort Notes edit References edit heapq Heap queue algorithm Python Standard Library Class PriorityQueue Java Platform Standard Ed Thomas Porter Istvan Simon Random Insertion into a Priority Queue Structure Stanford University Reports Stanford University p Retrieved January a b Cormen T H amp al Introduction to Algorithms nd ed Cambridge Massachusetts The MIT Press ISBN Suchenek Marek A Elementary Yet Precise Worst Case Analysis of Floyd s Heap Construction Program Fundamenta Informaticae IOS Press doi FI Poul Henning Kamp You re Doing It Wrong ACM Queue June Chris L Kuszmaul binary heap Dictionary of Algorithms and Data Structures Paul E Black ed U S National Institute of Standards and Technology November J R Sack and T Strothotte An Algorithm for Merging Heaps Acta Informatica J R Sack and T Strothotte A characterization of heaps and its applications Information and Computation Volume Issue May Pages Atkinson M D J R Sack N Santoro and T Strothotte October Min max heaps and generalized priority queues Programming techniques and Data structures Comm ACM External links edit Binary Heap Applet by Kubo Kovac Using Binary Heaps in A Pathfinding Open Data Structures Section BinaryHeap An Implicit Binary Tree v t e Data structures Types Collection Container Abstract Associative array Double ended priority queue Double ended queue List Multimap Priority queue Queue Set multiset Disjoint Sets Stack Arrays Bit array Circular buffer Dynamic array Hash table Hashed array tree Sparse array Linked Association list Linked list Skip list Unrolled linked list XOR linked list Trees B tree Binary search tree AA AVL red black self balancing splay Heap binary binomial Fibonacci R tree R R Hilbert Trie Hash tree Graphs Binary decision diagram Directed acyclic word graph List of data structures Retrieved from http en wikipedia org w index php title Binary heap amp oldid Categories Heaps data structures Navigation menu Personal tools Create account Log in Namespaces Article Talk Variants Views Read Edit View history Actions Search Navigation Main page Contents Featured content Current events Random article Donate to Wikipedia Wikimedia Shop Interaction Help About Wikipedia Community portal Recent changes Contact page Tools What links here Related changes Upload file Special pages Permanent link Page information Data item Cite this page Print export Create a book Download as PDF Printable version Languages Catal e tina Deutsch Espa ol Fran ais Magyar Polski Sloven ina Ti ng Vi t Edit links This page was last modified on February at Text is available under the Creative Commons Attribution ShareAlike License additional terms may apply By using this site you agree to the Terms of Use and Privacy Policy Wikipedia is a registered trademark of the Wikimedia Foundation Inc a non profit organization Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Mobile view if window mw mw loader state site loading user ready user groups ready if window mw mw loader load ext cite mobile desktop mediawiki action view postEdit mediawiki user mediawiki hidpi mediawiki page ready mediawiki searchSuggest ext gadget teahouse ext gadget ReferenceTooltips ext gadget DRN wizard ext gadget charinsert mw MwEmbedSupport style ext navigationTiming schema UniversalLanguageSelector ext uls eventlogger ext uls interlanguage skins vector collapsibleNav null true 