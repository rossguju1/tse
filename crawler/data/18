
http://old-www.cs.dartmouth.edu/~cs50/data/tse/wikipedia/wiki/Constant_time.html
2
Time complexity Wikipedia the free encyclopedia a lang ar a lang kk arab a lang mzn a lang ps a lang ur text decoration none cache key enwiki resourceloader filter minify css d a aa f a dc f be e if window mw mw config set wgCanonicalNamespace wgCanonicalSpecialPageName false wgNamespaceNumber wgPageName Time complexity wgTitle Time complexity wgCurRevisionId wgRevisionId wgArticleId wgIsArticle true wgIsRedirect false wgAction view wgUserName null wgUserGroups wgCategories Pages containing cite templates with deprecated parameters Articles needing additional references from January All articles needing additional references Use dmy dates from September Analysis of algorithms Computational complexity theory Computational resources wgBreakFrames false wgPageContentLanguage en wgPageContentModel wikitext wgSeparatorTransformTable wgDigitTransformTable wgDefaultDateFormat dmy wgMonthNames January February March April May June July August September October November December wgMonthNamesShort Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec wgRelevantPageName Time complexity wgIsProbablyEditable true wgRestrictionEdit wgRestrictionMove wgRedirectedFrom Constant time wgWikiEditorEnabledModules toolbar true dialogs true hidesig true templateEditor false templates false preview false previewDialog false publish false toc false wgBetaFeaturesFeatures wgVisualEditor isPageWatched false magnifyClipIconURL bits wikimedia org static wmf skins common images magnify clip png pageLanguageCode en pageLanguageDir ltr svgMaxSize wikilove recipient wikilove anon wgGuidedTourHelpGuiderUrl Help Guided tours guider wgFlowTermsOfUseEdit By saving changes you agree to our u Ca class external text href wikimediafoundation org wiki Terms of use u ETerms of Use u C a u E and agree to irrevocably release your text under the u Ca rel nofollow class external text href creativecommons org licenses by sa u ECC BY SA License u C a u E and u Ca class external text href en wikipedia org wiki Wikipedia Text of the GNU Free Documentation License u EGFDL u C a u E wgULSAcceptLanguageList wgULSCurrentAutonym English wgFlaggedRevsParams tags status levels quality pristine wgStableRevisionId null wgCategoryTreePageCategoryOptions mode hideprefix showcount true namespaces false wgNoticeProject wikipedia wgRedirectToFragment Constant time wgWikibaseItemId Q if window mw mw loader implement user options function mw user options set ccmeonemails cols date default diffonly disablemail editfont default editondblclick editsectiononrightclick enotifminoredits enotifrevealaddr enotifusertalkpages enotifwatchlistpages extendwatchlist fancysig forceeditsummary gender unknown hideminor hidepatrolled imagesize math minordefault newpageshidepatrolled nickname norollbackdiff numberheadings previewonfirst previewontop rcdays rclimit rememberpassword rows showhiddencats false shownumberswatching showtoolbar skin vector stubthreshold thumbsize underline uselivepreview usenewrc watchcreations watchdefault watchdeletion watchlistdays watchlisthideanons watchlisthidebots watchlisthideliu watchlisthideminor watchlisthideown watchlisthidepatrolled watchmoves wllimit useeditwarning prefershttps flaggedrevssimpleui flaggedrevsstable flaggedrevseditdiffs true flaggedrevsviewdiffs false usebetatoolbar usebetatoolbar cgd visualeditor enable visualeditor enable experimental visualeditor betatempdisable wikilove enabled echo subscriptions web page review true echo subscriptions email page review false ep showtoplink false ep bulkdelorgs false ep bulkdelcourses true ep showdyk true echo subscriptions web education program true echo subscriptions email education program false echo notify show link true echo show alert true echo email frequency echo email format html echo subscriptions email system true echo subscriptions web system true echo subscriptions email other false echo subscriptions web other true echo subscriptions email edit user talk false echo subscriptions web edit user talk true echo subscriptions email reverted false echo subscriptions web reverted true echo subscriptions email article linked false echo subscriptions web article linked false echo subscriptions email mention false echo subscriptions web mention true echo subscriptions web edit thank true echo subscriptions email edit thank false echo subscriptions web flow discussion true echo subscriptions email flow discussion false gettingstarted task toolbar show intro true uls preferences language en variant gan gan variant iu iu variant kk kk variant ku ku variant shi shi variant sr sr variant tg tg variant uz uz variant zh zh searchNs true searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false searchNs false gadget teahouse gadget ReferenceTooltips gadget DRN wizard gadget charinsert gadget mySandbox variant en mw loader implement user tokens function mw user tokens set editToken patrolToken false watchToken false cache key enwiki resourceloader filter minify js e d ede d d dc cd if window mw mw loader load mediawiki action view redirectToFragment mediawiki page startup mediawiki legacy wikibits mediawiki legacy ajax ext centralauth centralautologin skins vector compactPersonalBar defaultTracking ext visualEditor viewPageTarget init ext uls init ext uls interface wikibase client init ext centralNotice bannerController skins vector js body behavior url w static wmf skins vector csshover min htc Time complexity From Wikipedia the free encyclopedia Redirected from Constant time Jump to navigation search Running time redirects here For the film see Running Time film This article needs additional citations for verification Please help improve this article by adding citations to reliable sources Unsourced material may be challenged and removed January In computer science the time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the string representing the input The time complexity of an algorithm is commonly expressed using big O notation which excludes coefficients and lower order terms When expressed this way the time complexity is said to be described asymptotically i e as the input size goes to infinity For example if the time required by an algorithm on all inputs of size n is at most n n the asymptotic time complexity is O n Time complexity is commonly estimated by counting the number of elementary operations performed by the algorithm where an elementary operation takes a fixed amount of time to perform Thus the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor Since an algorithm s performance time may vary with different inputs of the same size one commonly uses the worst case time complexity of an algorithm denoted as T n which is defined as the maximum amount of time taken on any input of size n Time complexities are classified by the nature of the function T n For instance an algorithm with T n O n is called a linear time algorithm and an algorithm with T n O n is said to be an exponential time algorithm Contents Table of common time complexities Constant time Logarithmic time Polylogarithmic time Sub linear time Linear time Linearithmic time Quasilinear time Sub quadratic time Polynomial time Strongly and weakly polynomial time Complexity classes Superpolynomial time Quasi polynomial time Relation to NP complete problems Sub exponential time First definition Second definition Exponential time hypothesis Exponential time Double exponential time See also References Table of common time complexities edit Further information Computational complexity of mathematical operations The following table summarizes some classes of commonly encountered time complexities In the table poly x x O i e polynomial in x Name Complexity class Running time T n Examples of running times Example algorithms constant time O Determining if an integer represented in binary is even or odd inverse Ackermann time O n Amortized time per operation using a disjoint set iterated logarithmic time O log n Distributed coloring of cycles log logarithmic O log log n Amortized time per operation using a bounded priority queue logarithmic time DLOGTIME O log n log n log n Binary search polylogarithmic time poly log n log n fractional power O n c where lt c lt n n Searching in a kd tree linear time O n n Finding the smallest item in an unsorted array n log star n time O n log n Seidel s polygon triangulation algorithm linearithmic time O n log n n log n log n Fastest possible comparison sort quadratic time O n n Bubble sort Insertion sort Direct convolution cubic time O n n Naive multiplication of two n n matrices Calculating partial correlation polynomial time P O log n poly n n n log n n Karmarkar s algorithm for linear programming AKS primality test quasi polynomial time QP poly log n n log log n n log n Best known O log n approximation algorithm for the directed Steiner tree problem sub exponential time first definition SUBEXP O n for all gt O log n log log n Assuming complexity theoretic conjectures BPP is contained in SUBEXP sub exponential time second definition o n n Best known algorithm for integer factorization and graph isomorphism exponential time E O n n n Solving the traveling salesman problem using dynamic programming factorial time O n n Solving the traveling salesman problem via brute force search exponential time EXPTIME poly n n n double exponential time EXPTIME poly n n Deciding the truth of a given statement in Presburger arithmetic Constant time edit An algorithm is said to be constant time also written as O time if the value of T n is bounded by a value that does not depend on the size of the input For example accessing any single element in an array takes constant time as only one operation has to be performed to locate it However finding the minimal value in an unordered array is not a constant time operation as a scan over each element in the array is needed in order to determine the minimal value Hence it is a linear time operation taking O n time If the number of elements is known in advance and does not change however such an algorithm can still be said to run in constant time Despite the name constant time the running time does not have to be independent of the problem size but an upper bound for the running time has to be bounded independently of the problem size For example the task exchange the values of a and b if necessary so that a b is called constant time even though the time may depend on whether or not it is already true that a b However there is some constant t such that the time required is always at most t Here are some examples of code fragments that run in constant time int index int item list index if condition true then perform some operation that runs in constant time else perform some other operation that runs in constant time for i to for j to perform some operation that runs in constant time If T n is O any constant value this is equivalent to and stated in standard notation as T n being O Logarithmic time edit Further information Logarithmic growth An algorithm is said to take logarithmic time if T n O log n Due to the use of the binary numeral system by computers the logarithm is frequently base that is log n sometimes written lg n However by the change of base for logarithms log a n and log b n differ only by a constant multiplier which in big O notation is discarded thus O log n is the standard notation for logarithmic time algorithms regardless of the base of the logarithm Algorithms taking logarithmic time are commonly found in operations on binary trees or when using binary search An O log n algorithm is considered highly efficient as the operations per instance required to complete decrease with each instance A very simple example of this type of f n is an algorithm that cuts a string in half It will take O log n time n being the length of the string since we chop the string in half before each print we make the assumption that console log and str substring run in constant time This means in order to increase the number of prints we have to double the length of the string Function to recursively print the right half of a string var right function str var length str length Helper function var help function index Recursive Case Print right half if index lt length Prints characters from index until the end of the array console log str substring index length Recursive Call call help on right half help Math ceil length index Base Case Do Nothing help Polylogarithmic time edit An algorithm is said to run in polylogarithmic time if T n O log n k for some constant k For example matrix chain ordering can be solved in polylogarithmic time on a Parallel Random Access Machine Sub linear time edit An algorithm is said to run in sub linear time often spelled sublinear time if T n o n In particular this includes algorithms with the time complexities defined above as well as others such as the O n Grover s search algorithm Typical algorithms that are exact and yet run in sub linear time use parallel processing as the NC matrix determinant calculation does non classical processing as Grover s search does or alternatively have guaranteed assumptions on the input structure as the logarithmic time binary search and many tree maintenance algorithms do However languages such as the set of all strings that have a bit in the position indicated by the first log n bits of the string may depend on every bit of the input and yet be computable in sub linear time The specific term sublinear time algorithm is usually reserved to algorithms that are unlike the above in that they are run over classical serial machine models and are not allowed prior assumptions on the input They are however allowed to be randomized and indeed must be randomized for all but the most trivial of tasks As such an algorithm must provide an answer without reading the entire input its particulars heavily depend on the access allowed to the input Usually for an input that is represented as a binary string b b k it is assumed that the algorithm can in time O request and obtain the value of b i for any i Sub linear time algorithms are typically randomized and provide only approximate solutions In fact the property of a binary string having only zeros and no ones can be easily proved not to be decidable by a non approximate sub linear time algorithm Sub linear time algorithms arise naturally in the investigation of property testing Linear time edit An algorithm is said to take linear time or O n time if its time complexity is O n Informally this means that for large enough input sizes the running time increases linearly with the size of the input For example a procedure that adds up all elements of a list requires time proportional to the length of the list This description is slightly inaccurate since the running time can significantly deviate from a precise proportionality especially for small values of n Linear time is often viewed as a desirable attribute for an algorithm Much research has been invested into creating algorithms exhibiting nearly linear time or better This research includes both software and hardware methods In the case of hardware some algorithms which mathematically speaking can never achieve linear time with standard computation models are able to run in linear time There are several hardware technologies which exploit parallelism to provide this An example is content addressable memory This concept of linear time is used in string matching algorithms such as the Boyer Moore Algorithm and Ukkonen s Algorithm Linearithmic time edit A linearithmic function portmanteau of linear and logarithmic is a function of the form n log n i e a product of a linear and a logarithmic term An algorithm is said to run in linearithmic time if T n O n log n Compared to other functions a linearithmic function is n o n for every gt and n log n Thus a linearithmic term grows faster than a linear term but slower than any polynomial in n with exponent strictly greater than In many cases the n log n running time is simply the result of performing a log n operation n times For example binary tree sort creates a binary tree by inserting each element of the n sized array one by one Since the insert operation on a self balancing binary search tree takes O log n time the entire algorithm takes linearithmic time Comparison sorts require at least linearithmic number of comparisons in the worst case because log n n log n by Stirling s approximation They also frequently arise from the recurrence relation T n T n O n Some famous algorithms that run in linearithmic time include Quicksort in the average case Heapsort merge sort introsort binary tree sort smoothsort patience sorting etc in the worst case Fast Fourier transforms Monge array calculation Quasilinear time edit A generalization of linearithmic time is quasilinear time An algorithm is said to run in quasilinear time if T n O n log k n for any constant k linearithmic time is the case k Quasilinear time algorithms are also o n for every gt and thus run faster than any polynomial in n with exponent strictly greater than Algorithms which run in quasilinear time in addition to the linearithmic algorithms listed above include In place merge sort O n log n Sub quadratic time edit An algorithm is said to be subquadratic time if T n o n For example most na ve comparison based sorting algorithms are quadratic e g insertion sort but more advanced algorithms can be found that are subquadratic e g Shell sort No general purpose sorts run in linear time but the change from quadratic to sub quadratic is of great practical importance Polynomial time edit An algorithm is said to be of polynomial time if its running time is upper bounded by a polynomial expression in the size of the input for the algorithm i e T n O n k for some constant k Problems for which a deterministic polynomial time algorithm exists belong to the complexity class P which is central in the field of computational complexity theory Cobham s thesis states that polynomial time is a synonym for tractable feasible efficient or fast Some examples of polynomial time algorithms The quicksort sorting algorithm on n integers performs at most operations for some constant A Thus it runs in time and is a polynomial time algorithm All the basic arithmetic operations addition subtraction multiplication division and comparison can be done in polynomial time Maximum matchings in graphs can be found in polynomial time Strongly and weakly polynomial time edit In some contexts especially in optimization one differentiates between strongly polynomial time and weakly polynomial time algorithms These two concepts are only relevant if the inputs to the algorithms consist of integers Strongly polynomial time is defined in the arithmetic model of computation In this model of computation the basic arithmetic operations addition subtraction multiplication division and comparison take a unit time step to perform regardless of the sizes of the operands The algorithm runs in strongly polynomial time if the number of operations in the arithmetic model of computation is bounded by a polynomial in the number of integers in the input instance and the space used by the algorithm is bounded by a polynomial in the size of the input Any algorithm with these two properties can be converted to a polynomial time algorithm by replacing the arithmetic operations by suitable algorithms for performing the arithmetic operations on a Turing machine If the second of the above requirement is not met then this is not true anymore Given the integer which takes up space proportional to n it is possible to compute with n multiplications using repeated squaring However the space used to represent is proportional to and thus exponential rather than polynomial in the space used to represent the input Hence it is not possible to carry out this computation in polynomial time on a Turing machine but it is possible to compute it by polynomially many arithmetic operations Conversely there are algorithms which run in a number of Turing machine steps bounded by a polynomial in the length of binary encoded input but do not take a number of arithmetic operations bounded by a polynomial in the number of input numbers The Euclidean algorithm for computing the greatest common divisor of two integers is one example Given two integers and the running time of the algorithm is bounded by Turing machine steps This is polynomial in the size of a binary representation of and as the size of such a representation is roughly At the same time the number of arithmetic operations cannot be bound by the number of integers in the input which is constant in this case there are always only two integers in the input Due to the latter observation the algorithm does not run in strongly polynomial time Its real running time depends on the magnitudes of and and not only on the number of integers in the input An algorithm which runs in polynomial time but which is not strongly polynomial is said to run in weakly polynomial time A well known example of a problem for which a weakly polynomial time algorithm is known but is not known to admit a strongly polynomial time algorithm is linear programming Weakly polynomial time should not be confused with pseudo polynomial time Complexity classes edit The concept of polynomial time leads to several complexity classes in computational complexity theory Some important classes defined using polynomial time are the following P The complexity class of decision problems that can be solved on a deterministic Turing machine in polynomial time NP The complexity class of decision problems that can be solved on a non deterministic Turing machine in polynomial time ZPP The complexity class of decision problems that can be solved with zero error on a probabilistic Turing machine in polynomial time RP The complexity class of decision problems that can be solved with sided error on a probabilistic Turing machine in polynomial time BPP The complexity class of decision problems that can be solved with sided error on a probabilistic Turing machine in polynomial time BQP The complexity class of decision problems that can be solved with sided error on a quantum Turing machine in polynomial time P is the smallest time complexity class on a deterministic machine which is robust in terms of machine model changes For example a change from a single tape Turing machine to a multi tape machine can lead to a quadratic speedup but any algorithm that runs in polynomial time under one model also does so on the other Any given abstract machine will have a complexity class corresponding to the problems which can be solved in polynomial time on that machine Superpolynomial time edit An algorithm is said to take superpolynomial time if T n is not bounded above by any polynomial It is n c time for all constants c where n is the input parameter typically the number of bits in the input For example an algorithm that runs for n steps on an input of size n requires superpolynomial time more specifically exponential time An algorithm that uses exponential resources is clearly superpolynomial but some algorithms are only very weakly superpolynomial For example the Adleman Pomerance Rumely primality test runs for n O log log n time on n bit inputs this grows faster than any polynomial for large enough n but the input size must become impractically large before it cannot be dominated by a polynomial with small degree An algorithm that requires superpolynomial time lies outside the complexity class P Cobham s thesis posits that these algorithms are impractical and in many cases they are Since the P versus NP problem is unresolved no algorithm for an NP complete problem is currently known to run in polynomial time Quasi polynomial time edit Quasi polynomial time algorithms are algorithms which run slower than polynomial time yet not so slow as to be exponential time The worst case running time of a quasi polynomial time algorithm is for some fixed c The best known classical algorithm for integer factorization the general number field sieve which runs in time about is not quasi polynomial since the running time cannot be expressed as for some fixed c If the constant c in the definition of quasi polynomial time algorithms is equal to we get a polynomial time algorithm and if it is less than we get a sub linear time algorithm Quasi polynomial time algorithms typically arise in reductions from an NP hard problem to another problem For example one can take an instance of an NP hard problem say SAT and convert it to an instance of another problem B but the size of the instance becomes In that case this reduction does not prove that problem B is NP hard this reduction only shows that there is no polynomial time algorithm for B unless there is a quasi polynomial time algorithm for SAT and thus all of NP Similarly there are some problems for which we know quasi polynomial time algorithms but no polynomial time algorithm is known Such problems arise in approximation algorithms a famous example is the directed Steiner tree problem for which there is a quasi polynomial time approximation algorithm achieving an approximation factor of n being the number of vertices but showing the existence of such a polynomial time algorithm is an open problem The complexity class QP consists of all problems which have quasi polynomial time algorithms It can be defined in terms of DTIME as follows Relation to NP complete problems edit In complexity theory the unsolved P versus NP problem asks if all problems in NP have polynomial time algorithms All the best known algorithms for NP complete problems like SAT etc take exponential time Indeed it is conjectured for many natural NP complete problems that they do not have sub exponential time algorithms Here sub exponential time is taken to mean the second definition presented above On the other hand many graph problems represented in the natural way by adjacency matrices are solvable in subexponential time simply because the size of the input is square of the number of vertices This conjecture for the k SAT problem is known as the exponential time hypothesis Since it is conjectured that NP complete problems do not have quasi polynomial time algorithms some inapproximability results in the field of approximation algorithms make the assumption that NP complete problems do not have quasi polynomial time algorithms For example see the known inapproximability results for the set cover problem Sub exponential time edit The term sub exponential time is used to express that the running time of some algorithm may grow faster than any polynomial but is still significantly smaller than an exponential In this sense problems that have sub exponential time algorithms are somewhat more tractable than those that only have exponential algorithms The precise definition of sub exponential is not generally agreed upon and we list the two most widely used ones below First definition edit A problem is said to be sub exponential time solvable if it can be solved in running times whose logarithms grow smaller than any given polynomial More precisely a problem is in sub exponential time if for every gt there exists an algorithm which solves the problem in time O n The set of all such problems is the complexity class SUBEXP which can be defined in terms of DTIME as follows Note that this notion of sub exponential is non uniform in terms of in the sense that is not part of the input and each may have its own algorithm for the problem Second definition edit Some authors define sub exponential time as running times in o n This definition allows larger running times than the first definition of sub exponential time An example of such a sub exponential time algorithm is the best known classical algorithm for integer factorization the general number field sieve which runs in time about where the length of the input is n Another example is the best known algorithm for the graph isomorphism problem which runs in time O n log n Note that it makes a difference whether the algorithm is allowed to be sub exponential in the size of the instance the number of vertices or the number of edges In parameterized complexity this difference is made explicit by considering pairs of decision problems and parameters k SUBEPT is the class of all parameterized problems that run in time sub exponential in k and polynomial in the input size n More precisely SUBEPT is the class of all parameterized problems for which there is a computable function with and an algorithm that decides L in time Exponential time hypothesis edit Main article Exponential time hypothesis The exponential time hypothesis ETH is that SAT the satisfiability problem of Boolean formulas in conjunctive normal form with at most three literals per clause and with n variables cannot be solved in time o n More precisely the hypothesis is that there is some absolute constant c gt such that SAT cannot be decided in time cn by any deterministic Turing machine With m denoting the number of clauses ETH is equivalent to the hypothesis that k SAT cannot be solved in time o m for any integer k The exponential time hypothesis implies P NP Exponential time edit An algorithm is said to be exponential time if T n is upper bounded by poly n where poly n is some polynomial in n More formally an algorithm is exponential time if T n is bounded by O n k for some constant k Problems which admit exponential time algorithms on a deterministic Turing machine form the complexity class known as EXP Sometimes exponential time is used to refer to algorithms that have T n O n where the exponent is at most a linear function of n This gives rise to the complexity class E Double exponential time edit An algorithm is said to be double exponential time if T n is upper bounded by poly n where poly n is some polynomial in n Such algorithms belong to the complexity class EXPTIME Well known double exponential time algorithms include Decision procedures for Presburger arithmetic Computing a Gr bner basis in the worst case Quantifier elimination on real closed fields takes at least double exponential time but is not even known to be computable in ELEMENTARY See also edit L notation References edit a b Sipser Michael Introduction to the Theory of Computation Course Technology Inc ISBN Mehlhorn Kurt Naher Stefan Bounded ordered dictionaries in O log log N time and O n space Information Processing Letters doi P a b Babai L szl Fortnow Lance Nisan N Wigderson Avi BPP has subexponential time simulations unless EXPTIME has publishable proofs Computational Complexity Berlin New York Springer Verlag doi BF Bradford Phillip G Rawlins Gregory J E Shannon Gregory E Efficient Matrix Chain Ordering in Polylog Time SIAM Journal on Computing Philadelphia Society for Industrial and Applied Mathematics doi S ISSN Kumar Ravi Rubinfeld Ronitt Sublinear time algorithms SIGACT News Papadimitriou Christos H Computational complexity Reading Mass Addison Wesley ISBN Cobham Alan The intrinsic computational difficulty of functions Proc Logic Methodology and Philosophy of Science II North Holland Gr tschel Martin L szl Lov sz Alexander Schrijver Complexity Oracles and Numerical Computation Geometric Algorithms and Combinatorial Optimization Springer ISBN X Cite uses deprecated parameters help Schrijver Alexander Preliminaries on algorithms and Complexity Combinatorial Optimization Polyhedra and Efficiency Springer ISBN Complexity Zoo Class QP Quasipolynomial Time a b Impagliazzo R Paturi R On the complexity of k SAT Journal of Computer and System Sciences Elsevier doi jcss ISSN Aaronson Scott April A not quite exponential dilemma Shtetl Optimized Retrieved December Complexity Zoo Class SUBEXP Deterministic Subexponential Time Moser P Baire s Categories on Small Complexity Classes Lecture Notes in Computer Science Berlin New York Springer Verlag ISSN Miltersen P B DERANDOMIZING COMPLEXITY CLASSES Handbook of Randomized Computing Kluwer Academic Pub Kuperberg Greg A Subexponential Time Quantum Algorithm for the Dihedral Hidden Subgroup Problem SIAM Journal on Computing Philadelphia Society for Industrial and Applied Mathematics ISSN Oded Regev A Subexponential Time Algorithm for the Dihedral Hidden Subgroup Problem with Polynomial Space arXiv quant ph v quant ph Flum J rg Grohe Martin Parameterized Complexity Theory Springer p ISBN Retrieved Impagliazzo R Paturi R Zane F Which problems have strongly exponential complexity Journal of Computer and System Sciences doi jcss Retrieved from http en wikipedia org w index php title Time complexity amp oldid Constant time Categories Analysis of algorithms Computational complexity theory Computational resources Hidden categories Pages containing cite templates with deprecated parameters Articles needing additional references from January All articles needing additional references Use dmy dates from September Navigation menu Personal tools Create account Log in Namespaces Article Talk Variants Views Read Edit View history Actions Search Navigation Main page Contents Featured content Current events Random article Donate to Wikipedia Wikimedia Shop Interaction Help About Wikipedia Community portal Recent changes Contact page Tools What links here Related changes Upload file Special pages Permanent link Page information Data item Cite this page Print export Create a book Download as PDF Printable version Languages Deutsch Italiano srpski Edit links This page was last modified on March at Text is available under the Creative Commons Attribution ShareAlike License additional terms may apply By using this site you agree to the Terms of Use and Privacy Policy Wikipedia is a registered trademark of the Wikimedia Foundation Inc a non profit organization Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Mobile view if window mw mw loader state site loading user ready user groups ready if window mw mw loader load ext cite mobile desktop mediawiki action view postEdit mediawiki user mediawiki hidpi mediawiki page ready mediawiki searchSuggest ext gadget teahouse ext gadget ReferenceTooltips ext gadget DRN wizard ext gadget charinsert mw MwEmbedSupport style ext navigationTiming schema UniversalLanguageSelector ext uls eventlogger ext uls interlanguage skins vector collapsibleNav null true 